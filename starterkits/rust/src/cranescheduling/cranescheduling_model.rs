// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `cranescheduling_model.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct Block {
    // message fields
    pub Id: i32,
    pub Class: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // int32 Class = 2;


    pub fn get_Class(&self) -> i32 {
        self.Class
    }
    pub fn clear_Class(&mut self) {
        self.Class = 0;
    }

    // Param is passed by value, moved
    pub fn set_Class(&mut self, v: i32) {
        self.Class = v;
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Class = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Class != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Class, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.Class != 0 {
            os.write_int32(2, self.Class)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Block| { &m.Id },
                    |m: &mut Block| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Class",
                    |m: &Block| { &m.Class },
                    |m: &mut Block| { &mut m.Class },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Block,
        };
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.Id = 0;
        self.Class = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Crane {
    // message fields
    pub Id: i32,
    pub Load: ::protobuf::SingularPtrField<Stack>,
    pub GirderPosition: f64,
    pub HoistLevel: f64,
    pub CraneCapacity: i32,
    pub Width: f64,
    pub MinPosition: f64,
    pub MaxPosition: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Crane {
    fn default() -> &'a Crane {
        <Crane as ::protobuf::Message>::default_instance()
    }
}

impl Crane {
    pub fn new() -> Crane {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // .DynStacking.CraneScheduling.DataModel.Stack Load = 2;


    pub fn get_Load(&self) -> &Stack {
        self.Load.as_ref().unwrap_or_else(|| Stack::default_instance())
    }
    pub fn clear_Load(&mut self) {
        self.Load.clear();
    }

    pub fn has_Load(&self) -> bool {
        self.Load.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Load(&mut self, v: Stack) {
        self.Load = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Load(&mut self) -> &mut Stack {
        if self.Load.is_none() {
            self.Load.set_default();
        }
        self.Load.as_mut().unwrap()
    }

    // Take field
    pub fn take_Load(&mut self) -> Stack {
        self.Load.take().unwrap_or_else(|| Stack::new())
    }

    // double GirderPosition = 3;


    pub fn get_GirderPosition(&self) -> f64 {
        self.GirderPosition
    }
    pub fn clear_GirderPosition(&mut self) {
        self.GirderPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_GirderPosition(&mut self, v: f64) {
        self.GirderPosition = v;
    }

    // double HoistLevel = 4;


    pub fn get_HoistLevel(&self) -> f64 {
        self.HoistLevel
    }
    pub fn clear_HoistLevel(&mut self) {
        self.HoistLevel = 0.;
    }

    // Param is passed by value, moved
    pub fn set_HoistLevel(&mut self, v: f64) {
        self.HoistLevel = v;
    }

    // int32 CraneCapacity = 5;


    pub fn get_CraneCapacity(&self) -> i32 {
        self.CraneCapacity
    }
    pub fn clear_CraneCapacity(&mut self) {
        self.CraneCapacity = 0;
    }

    // Param is passed by value, moved
    pub fn set_CraneCapacity(&mut self, v: i32) {
        self.CraneCapacity = v;
    }

    // double Width = 6;


    pub fn get_Width(&self) -> f64 {
        self.Width
    }
    pub fn clear_Width(&mut self) {
        self.Width = 0.;
    }

    // Param is passed by value, moved
    pub fn set_Width(&mut self, v: f64) {
        self.Width = v;
    }

    // double MinPosition = 7;


    pub fn get_MinPosition(&self) -> f64 {
        self.MinPosition
    }
    pub fn clear_MinPosition(&mut self) {
        self.MinPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_MinPosition(&mut self, v: f64) {
        self.MinPosition = v;
    }

    // double MaxPosition = 8;


    pub fn get_MaxPosition(&self) -> f64 {
        self.MaxPosition
    }
    pub fn clear_MaxPosition(&mut self) {
        self.MaxPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_MaxPosition(&mut self, v: f64) {
        self.MaxPosition = v;
    }
}

impl ::protobuf::Message for Crane {
    fn is_initialized(&self) -> bool {
        for v in &self.Load {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Load)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.GirderPosition = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.HoistLevel = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CraneCapacity = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.Width = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.MinPosition = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.MaxPosition = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Load.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.GirderPosition != 0. {
            my_size += 9;
        }
        if self.HoistLevel != 0. {
            my_size += 9;
        }
        if self.CraneCapacity != 0 {
            my_size += ::protobuf::rt::value_size(5, self.CraneCapacity, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Width != 0. {
            my_size += 9;
        }
        if self.MinPosition != 0. {
            my_size += 9;
        }
        if self.MaxPosition != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if let Some(ref v) = self.Load.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.GirderPosition != 0. {
            os.write_double(3, self.GirderPosition)?;
        }
        if self.HoistLevel != 0. {
            os.write_double(4, self.HoistLevel)?;
        }
        if self.CraneCapacity != 0 {
            os.write_int32(5, self.CraneCapacity)?;
        }
        if self.Width != 0. {
            os.write_double(6, self.Width)?;
        }
        if self.MinPosition != 0. {
            os.write_double(7, self.MinPosition)?;
        }
        if self.MaxPosition != 0. {
            os.write_double(8, self.MaxPosition)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Crane {
        Crane::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Crane| { &m.Id },
                    |m: &mut Crane| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stack>>(
                    "Load",
                    |m: &Crane| { &m.Load },
                    |m: &mut Crane| { &mut m.Load },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "GirderPosition",
                    |m: &Crane| { &m.GirderPosition },
                    |m: &mut Crane| { &mut m.GirderPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "HoistLevel",
                    |m: &Crane| { &m.HoistLevel },
                    |m: &mut Crane| { &mut m.HoistLevel },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "CraneCapacity",
                    |m: &Crane| { &m.CraneCapacity },
                    |m: &mut Crane| { &mut m.CraneCapacity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "Width",
                    |m: &Crane| { &m.Width },
                    |m: &mut Crane| { &mut m.Width },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "MinPosition",
                    |m: &Crane| { &m.MinPosition },
                    |m: &mut Crane| { &mut m.MinPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "MaxPosition",
                    |m: &Crane| { &m.MaxPosition },
                    |m: &mut Crane| { &mut m.MaxPosition },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Crane>(
                    "Crane",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Crane {
        static mut instance: ::protobuf::lazy::Lazy<Crane> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Crane,
        };
        unsafe {
            instance.get(Crane::new)
        }
    }
}

impl ::protobuf::Clear for Crane {
    fn clear(&mut self) {
        self.Id = 0;
        self.Load.clear();
        self.GirderPosition = 0.;
        self.HoistLevel = 0.;
        self.CraneCapacity = 0;
        self.Width = 0.;
        self.MinPosition = 0.;
        self.MaxPosition = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Crane {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Crane {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneMove {
    // message fields
    pub Id: i32,
    pub Type: MoveType,
    pub PickupLocationId: i32,
    pub PickupGirderPosition: f64,
    pub DropoffLocationId: i32,
    pub DropoffGirderPosition: f64,
    pub Amount: i32,
    pub ReleaseTime: ::protobuf::SingularPtrField<TimeStamp>,
    pub DueDate: ::protobuf::SingularPtrField<TimeStamp>,
    pub RequiredCraneId: i32,
    pub ProtobufPredecessorIds: ::std::vec::Vec<i32>,
    pub ProtobufMovedBlockIds: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneMove {
    fn default() -> &'a CraneMove {
        <CraneMove as ::protobuf::Message>::default_instance()
    }
}

impl CraneMove {
    pub fn new() -> CraneMove {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // .DynStacking.CraneScheduling.DataModel.MoveType Type = 2;


    pub fn get_Type(&self) -> MoveType {
        self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type = MoveType::MoveToPickup;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: MoveType) {
        self.Type = v;
    }

    // int32 PickupLocationId = 3;


    pub fn get_PickupLocationId(&self) -> i32 {
        self.PickupLocationId
    }
    pub fn clear_PickupLocationId(&mut self) {
        self.PickupLocationId = 0;
    }

    // Param is passed by value, moved
    pub fn set_PickupLocationId(&mut self, v: i32) {
        self.PickupLocationId = v;
    }

    // double PickupGirderPosition = 4;


    pub fn get_PickupGirderPosition(&self) -> f64 {
        self.PickupGirderPosition
    }
    pub fn clear_PickupGirderPosition(&mut self) {
        self.PickupGirderPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_PickupGirderPosition(&mut self, v: f64) {
        self.PickupGirderPosition = v;
    }

    // int32 DropoffLocationId = 5;


    pub fn get_DropoffLocationId(&self) -> i32 {
        self.DropoffLocationId
    }
    pub fn clear_DropoffLocationId(&mut self) {
        self.DropoffLocationId = 0;
    }

    // Param is passed by value, moved
    pub fn set_DropoffLocationId(&mut self, v: i32) {
        self.DropoffLocationId = v;
    }

    // double DropoffGirderPosition = 6;


    pub fn get_DropoffGirderPosition(&self) -> f64 {
        self.DropoffGirderPosition
    }
    pub fn clear_DropoffGirderPosition(&mut self) {
        self.DropoffGirderPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_DropoffGirderPosition(&mut self, v: f64) {
        self.DropoffGirderPosition = v;
    }

    // int32 Amount = 7;


    pub fn get_Amount(&self) -> i32 {
        self.Amount
    }
    pub fn clear_Amount(&mut self) {
        self.Amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_Amount(&mut self, v: i32) {
        self.Amount = v;
    }

    // .DynStacking.CraneScheduling.DataModel.TimeStamp ReleaseTime = 8;


    pub fn get_ReleaseTime(&self) -> &TimeStamp {
        self.ReleaseTime.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_ReleaseTime(&mut self) {
        self.ReleaseTime.clear();
    }

    pub fn has_ReleaseTime(&self) -> bool {
        self.ReleaseTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ReleaseTime(&mut self, v: TimeStamp) {
        self.ReleaseTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ReleaseTime(&mut self) -> &mut TimeStamp {
        if self.ReleaseTime.is_none() {
            self.ReleaseTime.set_default();
        }
        self.ReleaseTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_ReleaseTime(&mut self) -> TimeStamp {
        self.ReleaseTime.take().unwrap_or_else(|| TimeStamp::new())
    }

    // .DynStacking.CraneScheduling.DataModel.TimeStamp DueDate = 9;


    pub fn get_DueDate(&self) -> &TimeStamp {
        self.DueDate.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_DueDate(&mut self) {
        self.DueDate.clear();
    }

    pub fn has_DueDate(&self) -> bool {
        self.DueDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DueDate(&mut self, v: TimeStamp) {
        self.DueDate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DueDate(&mut self) -> &mut TimeStamp {
        if self.DueDate.is_none() {
            self.DueDate.set_default();
        }
        self.DueDate.as_mut().unwrap()
    }

    // Take field
    pub fn take_DueDate(&mut self) -> TimeStamp {
        self.DueDate.take().unwrap_or_else(|| TimeStamp::new())
    }

    // int32 RequiredCraneId = 10;


    pub fn get_RequiredCraneId(&self) -> i32 {
        self.RequiredCraneId
    }
    pub fn clear_RequiredCraneId(&mut self) {
        self.RequiredCraneId = 0;
    }

    // Param is passed by value, moved
    pub fn set_RequiredCraneId(&mut self, v: i32) {
        self.RequiredCraneId = v;
    }

    // repeated int32 ProtobufPredecessorIds = 12;


    pub fn get_ProtobufPredecessorIds(&self) -> &[i32] {
        &self.ProtobufPredecessorIds
    }
    pub fn clear_ProtobufPredecessorIds(&mut self) {
        self.ProtobufPredecessorIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProtobufPredecessorIds(&mut self, v: ::std::vec::Vec<i32>) {
        self.ProtobufPredecessorIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ProtobufPredecessorIds(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.ProtobufPredecessorIds
    }

    // Take field
    pub fn take_ProtobufPredecessorIds(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.ProtobufPredecessorIds, ::std::vec::Vec::new())
    }

    // repeated int32 ProtobufMovedBlockIds = 13;


    pub fn get_ProtobufMovedBlockIds(&self) -> &[i32] {
        &self.ProtobufMovedBlockIds
    }
    pub fn clear_ProtobufMovedBlockIds(&mut self) {
        self.ProtobufMovedBlockIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_ProtobufMovedBlockIds(&mut self, v: ::std::vec::Vec<i32>) {
        self.ProtobufMovedBlockIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ProtobufMovedBlockIds(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.ProtobufMovedBlockIds
    }

    // Take field
    pub fn take_ProtobufMovedBlockIds(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.ProtobufMovedBlockIds, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CraneMove {
    fn is_initialized(&self) -> bool {
        for v in &self.ReleaseTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.DueDate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.PickupLocationId = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.PickupGirderPosition = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.DropoffLocationId = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.DropoffGirderPosition = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Amount = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ReleaseTime)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DueDate)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.RequiredCraneId = tmp;
                },
                12 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.ProtobufPredecessorIds)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.ProtobufMovedBlockIds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Type != MoveType::MoveToPickup {
            my_size += ::protobuf::rt::enum_size(2, self.Type);
        }
        if self.PickupLocationId != 0 {
            my_size += ::protobuf::rt::value_size(3, self.PickupLocationId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.PickupGirderPosition != 0. {
            my_size += 9;
        }
        if self.DropoffLocationId != 0 {
            my_size += ::protobuf::rt::value_size(5, self.DropoffLocationId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DropoffGirderPosition != 0. {
            my_size += 9;
        }
        if self.Amount != 0 {
            my_size += ::protobuf::rt::value_size(7, self.Amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ReleaseTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.DueDate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.RequiredCraneId != 0 {
            my_size += ::protobuf::rt::value_size(10, self.RequiredCraneId, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.ProtobufPredecessorIds {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.ProtobufMovedBlockIds {
            my_size += ::protobuf::rt::value_size(13, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.Type != MoveType::MoveToPickup {
            os.write_enum(2, self.Type.value())?;
        }
        if self.PickupLocationId != 0 {
            os.write_int32(3, self.PickupLocationId)?;
        }
        if self.PickupGirderPosition != 0. {
            os.write_double(4, self.PickupGirderPosition)?;
        }
        if self.DropoffLocationId != 0 {
            os.write_int32(5, self.DropoffLocationId)?;
        }
        if self.DropoffGirderPosition != 0. {
            os.write_double(6, self.DropoffGirderPosition)?;
        }
        if self.Amount != 0 {
            os.write_int32(7, self.Amount)?;
        }
        if let Some(ref v) = self.ReleaseTime.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.DueDate.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.RequiredCraneId != 0 {
            os.write_int32(10, self.RequiredCraneId)?;
        }
        for v in &self.ProtobufPredecessorIds {
            os.write_int32(12, *v)?;
        };
        for v in &self.ProtobufMovedBlockIds {
            os.write_int32(13, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneMove {
        CraneMove::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &CraneMove| { &m.Id },
                    |m: &mut CraneMove| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MoveType>>(
                    "Type",
                    |m: &CraneMove| { &m.Type },
                    |m: &mut CraneMove| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "PickupLocationId",
                    |m: &CraneMove| { &m.PickupLocationId },
                    |m: &mut CraneMove| { &mut m.PickupLocationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "PickupGirderPosition",
                    |m: &CraneMove| { &m.PickupGirderPosition },
                    |m: &mut CraneMove| { &mut m.PickupGirderPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "DropoffLocationId",
                    |m: &CraneMove| { &m.DropoffLocationId },
                    |m: &mut CraneMove| { &mut m.DropoffLocationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "DropoffGirderPosition",
                    |m: &CraneMove| { &m.DropoffGirderPosition },
                    |m: &mut CraneMove| { &mut m.DropoffGirderPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Amount",
                    |m: &CraneMove| { &m.Amount },
                    |m: &mut CraneMove| { &mut m.Amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "ReleaseTime",
                    |m: &CraneMove| { &m.ReleaseTime },
                    |m: &mut CraneMove| { &mut m.ReleaseTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "DueDate",
                    |m: &CraneMove| { &m.DueDate },
                    |m: &mut CraneMove| { &mut m.DueDate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "RequiredCraneId",
                    |m: &CraneMove| { &m.RequiredCraneId },
                    |m: &mut CraneMove| { &mut m.RequiredCraneId },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ProtobufPredecessorIds",
                    |m: &CraneMove| { &m.ProtobufPredecessorIds },
                    |m: &mut CraneMove| { &mut m.ProtobufPredecessorIds },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ProtobufMovedBlockIds",
                    |m: &CraneMove| { &m.ProtobufMovedBlockIds },
                    |m: &mut CraneMove| { &mut m.ProtobufMovedBlockIds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneMove>(
                    "CraneMove",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneMove {
        static mut instance: ::protobuf::lazy::Lazy<CraneMove> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneMove,
        };
        unsafe {
            instance.get(CraneMove::new)
        }
    }
}

impl ::protobuf::Clear for CraneMove {
    fn clear(&mut self) {
        self.Id = 0;
        self.Type = MoveType::MoveToPickup;
        self.PickupLocationId = 0;
        self.PickupGirderPosition = 0.;
        self.DropoffLocationId = 0;
        self.DropoffGirderPosition = 0.;
        self.Amount = 0;
        self.ReleaseTime.clear();
        self.DueDate.clear();
        self.RequiredCraneId = 0;
        self.ProtobufPredecessorIds.clear();
        self.ProtobufMovedBlockIds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneMove {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneMove {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneSchedule {
    // message fields
    pub ScheduleNr: i32,
    pub Activities: ::protobuf::RepeatedField<CraneScheduleActivity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneSchedule {
    fn default() -> &'a CraneSchedule {
        <CraneSchedule as ::protobuf::Message>::default_instance()
    }
}

impl CraneSchedule {
    pub fn new() -> CraneSchedule {
        ::std::default::Default::default()
    }

    // int32 ScheduleNr = 1;


    pub fn get_ScheduleNr(&self) -> i32 {
        self.ScheduleNr
    }
    pub fn clear_ScheduleNr(&mut self) {
        self.ScheduleNr = 0;
    }

    // Param is passed by value, moved
    pub fn set_ScheduleNr(&mut self, v: i32) {
        self.ScheduleNr = v;
    }

    // repeated .DynStacking.CraneScheduling.DataModel.CraneScheduleActivity Activities = 2;


    pub fn get_Activities(&self) -> &[CraneScheduleActivity] {
        &self.Activities
    }
    pub fn clear_Activities(&mut self) {
        self.Activities.clear();
    }

    // Param is passed by value, moved
    pub fn set_Activities(&mut self, v: ::protobuf::RepeatedField<CraneScheduleActivity>) {
        self.Activities = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Activities(&mut self) -> &mut ::protobuf::RepeatedField<CraneScheduleActivity> {
        &mut self.Activities
    }

    // Take field
    pub fn take_Activities(&mut self) -> ::protobuf::RepeatedField<CraneScheduleActivity> {
        ::std::mem::replace(&mut self.Activities, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CraneSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.Activities {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ScheduleNr = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Activities)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.ScheduleNr != 0 {
            my_size += ::protobuf::rt::value_size(1, self.ScheduleNr, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.Activities {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.ScheduleNr != 0 {
            os.write_int32(1, self.ScheduleNr)?;
        }
        for v in &self.Activities {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneSchedule {
        CraneSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ScheduleNr",
                    |m: &CraneSchedule| { &m.ScheduleNr },
                    |m: &mut CraneSchedule| { &mut m.ScheduleNr },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneScheduleActivity>>(
                    "Activities",
                    |m: &CraneSchedule| { &m.Activities },
                    |m: &mut CraneSchedule| { &mut m.Activities },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneSchedule>(
                    "CraneSchedule",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneSchedule {
        static mut instance: ::protobuf::lazy::Lazy<CraneSchedule> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneSchedule,
        };
        unsafe {
            instance.get(CraneSchedule::new)
        }
    }
}

impl ::protobuf::Clear for CraneSchedule {
    fn clear(&mut self) {
        self.ScheduleNr = 0;
        self.Activities.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneScheduleActivity {
    // message fields
    pub MoveId: i32,
    pub CraneId: i32,
    pub Priority: i32,
    pub State: CraneScheduleActivityState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneScheduleActivity {
    fn default() -> &'a CraneScheduleActivity {
        <CraneScheduleActivity as ::protobuf::Message>::default_instance()
    }
}

impl CraneScheduleActivity {
    pub fn new() -> CraneScheduleActivity {
        ::std::default::Default::default()
    }

    // int32 MoveId = 1;


    pub fn get_MoveId(&self) -> i32 {
        self.MoveId
    }
    pub fn clear_MoveId(&mut self) {
        self.MoveId = 0;
    }

    // Param is passed by value, moved
    pub fn set_MoveId(&mut self, v: i32) {
        self.MoveId = v;
    }

    // int32 CraneId = 2;


    pub fn get_CraneId(&self) -> i32 {
        self.CraneId
    }
    pub fn clear_CraneId(&mut self) {
        self.CraneId = 0;
    }

    // Param is passed by value, moved
    pub fn set_CraneId(&mut self, v: i32) {
        self.CraneId = v;
    }

    // int32 Priority = 3;


    pub fn get_Priority(&self) -> i32 {
        self.Priority
    }
    pub fn clear_Priority(&mut self) {
        self.Priority = 0;
    }

    // Param is passed by value, moved
    pub fn set_Priority(&mut self, v: i32) {
        self.Priority = v;
    }

    // .DynStacking.CraneScheduling.DataModel.CraneScheduleActivityState State = 4;


    pub fn get_State(&self) -> CraneScheduleActivityState {
        self.State
    }
    pub fn clear_State(&mut self) {
        self.State = CraneScheduleActivityState::Created;
    }

    // Param is passed by value, moved
    pub fn set_State(&mut self, v: CraneScheduleActivityState) {
        self.State = v;
    }
}

impl ::protobuf::Message for CraneScheduleActivity {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.MoveId = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CraneId = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Priority = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.State, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.MoveId != 0 {
            my_size += ::protobuf::rt::value_size(1, self.MoveId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.CraneId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.CraneId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Priority != 0 {
            my_size += ::protobuf::rt::value_size(3, self.Priority, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.State != CraneScheduleActivityState::Created {
            my_size += ::protobuf::rt::enum_size(4, self.State);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.MoveId != 0 {
            os.write_int32(1, self.MoveId)?;
        }
        if self.CraneId != 0 {
            os.write_int32(2, self.CraneId)?;
        }
        if self.Priority != 0 {
            os.write_int32(3, self.Priority)?;
        }
        if self.State != CraneScheduleActivityState::Created {
            os.write_enum(4, self.State.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneScheduleActivity {
        CraneScheduleActivity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "MoveId",
                    |m: &CraneScheduleActivity| { &m.MoveId },
                    |m: &mut CraneScheduleActivity| { &mut m.MoveId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "CraneId",
                    |m: &CraneScheduleActivity| { &m.CraneId },
                    |m: &mut CraneScheduleActivity| { &mut m.CraneId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Priority",
                    |m: &CraneScheduleActivity| { &m.Priority },
                    |m: &mut CraneScheduleActivity| { &mut m.Priority },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CraneScheduleActivityState>>(
                    "State",
                    |m: &CraneScheduleActivity| { &m.State },
                    |m: &mut CraneScheduleActivity| { &mut m.State },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneScheduleActivity>(
                    "CraneScheduleActivity",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneScheduleActivity {
        static mut instance: ::protobuf::lazy::Lazy<CraneScheduleActivity> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneScheduleActivity,
        };
        unsafe {
            instance.get(CraneScheduleActivity::new)
        }
    }
}

impl ::protobuf::Clear for CraneScheduleActivity {
    fn clear(&mut self) {
        self.MoveId = 0;
        self.CraneId = 0;
        self.Priority = 0;
        self.State = CraneScheduleActivityState::Created;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneScheduleActivity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneScheduleActivity {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CraneSchedulingSolution {
    // message fields
    pub CustomMoves: ::protobuf::RepeatedField<CraneMove>,
    pub Schedule: ::protobuf::SingularPtrField<CraneSchedule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CraneSchedulingSolution {
    fn default() -> &'a CraneSchedulingSolution {
        <CraneSchedulingSolution as ::protobuf::Message>::default_instance()
    }
}

impl CraneSchedulingSolution {
    pub fn new() -> CraneSchedulingSolution {
        ::std::default::Default::default()
    }

    // repeated .DynStacking.CraneScheduling.DataModel.CraneMove CustomMoves = 1;


    pub fn get_CustomMoves(&self) -> &[CraneMove] {
        &self.CustomMoves
    }
    pub fn clear_CustomMoves(&mut self) {
        self.CustomMoves.clear();
    }

    // Param is passed by value, moved
    pub fn set_CustomMoves(&mut self, v: ::protobuf::RepeatedField<CraneMove>) {
        self.CustomMoves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CustomMoves(&mut self) -> &mut ::protobuf::RepeatedField<CraneMove> {
        &mut self.CustomMoves
    }

    // Take field
    pub fn take_CustomMoves(&mut self) -> ::protobuf::RepeatedField<CraneMove> {
        ::std::mem::replace(&mut self.CustomMoves, ::protobuf::RepeatedField::new())
    }

    // .DynStacking.CraneScheduling.DataModel.CraneSchedule Schedule = 2;


    pub fn get_Schedule(&self) -> &CraneSchedule {
        self.Schedule.as_ref().unwrap_or_else(|| CraneSchedule::default_instance())
    }
    pub fn clear_Schedule(&mut self) {
        self.Schedule.clear();
    }

    pub fn has_Schedule(&self) -> bool {
        self.Schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Schedule(&mut self, v: CraneSchedule) {
        self.Schedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Schedule(&mut self) -> &mut CraneSchedule {
        if self.Schedule.is_none() {
            self.Schedule.set_default();
        }
        self.Schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_Schedule(&mut self) -> CraneSchedule {
        self.Schedule.take().unwrap_or_else(|| CraneSchedule::new())
    }
}

impl ::protobuf::Message for CraneSchedulingSolution {
    fn is_initialized(&self) -> bool {
        for v in &self.CustomMoves {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.CustomMoves)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Schedule)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.CustomMoves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.Schedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.CustomMoves {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.Schedule.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CraneSchedulingSolution {
        CraneSchedulingSolution::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneMove>>(
                    "CustomMoves",
                    |m: &CraneSchedulingSolution| { &m.CustomMoves },
                    |m: &mut CraneSchedulingSolution| { &mut m.CustomMoves },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneSchedule>>(
                    "Schedule",
                    |m: &CraneSchedulingSolution| { &m.Schedule },
                    |m: &mut CraneSchedulingSolution| { &mut m.Schedule },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CraneSchedulingSolution>(
                    "CraneSchedulingSolution",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CraneSchedulingSolution {
        static mut instance: ::protobuf::lazy::Lazy<CraneSchedulingSolution> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CraneSchedulingSolution,
        };
        unsafe {
            instance.get(CraneSchedulingSolution::new)
        }
    }
}

impl ::protobuf::Clear for CraneSchedulingSolution {
    fn clear(&mut self) {
        self.CustomMoves.clear();
        self.Schedule.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CraneSchedulingSolution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneSchedulingSolution {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Location {
    // message fields
    pub Id: i32,
    pub GirderPosition: f64,
    pub MaxHeight: i32,
    pub Stack: ::protobuf::SingularPtrField<Stack>,
    pub Type: StackTypes,
    pub Class: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Location {
    fn default() -> &'a Location {
        <Location as ::protobuf::Message>::default_instance()
    }
}

impl Location {
    pub fn new() -> Location {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // double GirderPosition = 2;


    pub fn get_GirderPosition(&self) -> f64 {
        self.GirderPosition
    }
    pub fn clear_GirderPosition(&mut self) {
        self.GirderPosition = 0.;
    }

    // Param is passed by value, moved
    pub fn set_GirderPosition(&mut self, v: f64) {
        self.GirderPosition = v;
    }

    // int32 MaxHeight = 3;


    pub fn get_MaxHeight(&self) -> i32 {
        self.MaxHeight
    }
    pub fn clear_MaxHeight(&mut self) {
        self.MaxHeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_MaxHeight(&mut self, v: i32) {
        self.MaxHeight = v;
    }

    // .DynStacking.CraneScheduling.DataModel.Stack Stack = 4;


    pub fn get_Stack(&self) -> &Stack {
        self.Stack.as_ref().unwrap_or_else(|| Stack::default_instance())
    }
    pub fn clear_Stack(&mut self) {
        self.Stack.clear();
    }

    pub fn has_Stack(&self) -> bool {
        self.Stack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Stack(&mut self, v: Stack) {
        self.Stack = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Stack(&mut self) -> &mut Stack {
        if self.Stack.is_none() {
            self.Stack.set_default();
        }
        self.Stack.as_mut().unwrap()
    }

    // Take field
    pub fn take_Stack(&mut self) -> Stack {
        self.Stack.take().unwrap_or_else(|| Stack::new())
    }

    // .DynStacking.CraneScheduling.DataModel.StackTypes Type = 5;


    pub fn get_Type(&self) -> StackTypes {
        self.Type
    }
    pub fn clear_Type(&mut self) {
        self.Type = StackTypes::ArrivalStack;
    }

    // Param is passed by value, moved
    pub fn set_Type(&mut self, v: StackTypes) {
        self.Type = v;
    }

    // int32 Class = 6;


    pub fn get_Class(&self) -> i32 {
        self.Class
    }
    pub fn clear_Class(&mut self) {
        self.Class = 0;
    }

    // Param is passed by value, moved
    pub fn set_Class(&mut self, v: i32) {
        self.Class = v;
    }
}

impl ::protobuf::Message for Location {
    fn is_initialized(&self) -> bool {
        for v in &self.Stack {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.GirderPosition = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.MaxHeight = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Stack)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.Type, 5, &mut self.unknown_fields)?
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Class = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.GirderPosition != 0. {
            my_size += 9;
        }
        if self.MaxHeight != 0 {
            my_size += ::protobuf::rt::value_size(3, self.MaxHeight, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Stack.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.Type != StackTypes::ArrivalStack {
            my_size += ::protobuf::rt::enum_size(5, self.Type);
        }
        if self.Class != 0 {
            my_size += ::protobuf::rt::value_size(6, self.Class, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.GirderPosition != 0. {
            os.write_double(2, self.GirderPosition)?;
        }
        if self.MaxHeight != 0 {
            os.write_int32(3, self.MaxHeight)?;
        }
        if let Some(ref v) = self.Stack.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.Type != StackTypes::ArrivalStack {
            os.write_enum(5, self.Type.value())?;
        }
        if self.Class != 0 {
            os.write_int32(6, self.Class)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Location {
        Location::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &Location| { &m.Id },
                    |m: &mut Location| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "GirderPosition",
                    |m: &Location| { &m.GirderPosition },
                    |m: &mut Location| { &mut m.GirderPosition },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "MaxHeight",
                    |m: &Location| { &m.MaxHeight },
                    |m: &mut Location| { &mut m.MaxHeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Stack>>(
                    "Stack",
                    |m: &Location| { &m.Stack },
                    |m: &mut Location| { &mut m.Stack },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StackTypes>>(
                    "Type",
                    |m: &Location| { &m.Type },
                    |m: &mut Location| { &mut m.Type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Class",
                    |m: &Location| { &m.Class },
                    |m: &mut Location| { &mut m.Class },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Location>(
                    "Location",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Location {
        static mut instance: ::protobuf::lazy::Lazy<Location> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Location,
        };
        unsafe {
            instance.get(Location::new)
        }
    }
}

impl ::protobuf::Clear for Location {
    fn clear(&mut self) {
        self.Id = 0;
        self.GirderPosition = 0.;
        self.MaxHeight = 0;
        self.Stack.clear();
        self.Type = StackTypes::ArrivalStack;
        self.Class = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Location {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MoveRequest {
    // message fields
    pub Id: i32,
    pub TargetLocationId: i32,
    pub BlockId: i32,
    pub DueDate: ::protobuf::SingularPtrField<TimeStamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MoveRequest {
    fn default() -> &'a MoveRequest {
        <MoveRequest as ::protobuf::Message>::default_instance()
    }
}

impl MoveRequest {
    pub fn new() -> MoveRequest {
        ::std::default::Default::default()
    }

    // int32 Id = 1;


    pub fn get_Id(&self) -> i32 {
        self.Id
    }
    pub fn clear_Id(&mut self) {
        self.Id = 0;
    }

    // Param is passed by value, moved
    pub fn set_Id(&mut self, v: i32) {
        self.Id = v;
    }

    // int32 TargetLocationId = 2;


    pub fn get_TargetLocationId(&self) -> i32 {
        self.TargetLocationId
    }
    pub fn clear_TargetLocationId(&mut self) {
        self.TargetLocationId = 0;
    }

    // Param is passed by value, moved
    pub fn set_TargetLocationId(&mut self, v: i32) {
        self.TargetLocationId = v;
    }

    // int32 BlockId = 3;


    pub fn get_BlockId(&self) -> i32 {
        self.BlockId
    }
    pub fn clear_BlockId(&mut self) {
        self.BlockId = 0;
    }

    // Param is passed by value, moved
    pub fn set_BlockId(&mut self, v: i32) {
        self.BlockId = v;
    }

    // .DynStacking.CraneScheduling.DataModel.TimeStamp DueDate = 4;


    pub fn get_DueDate(&self) -> &TimeStamp {
        self.DueDate.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_DueDate(&mut self) {
        self.DueDate.clear();
    }

    pub fn has_DueDate(&self) -> bool {
        self.DueDate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_DueDate(&mut self, v: TimeStamp) {
        self.DueDate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_DueDate(&mut self) -> &mut TimeStamp {
        if self.DueDate.is_none() {
            self.DueDate.set_default();
        }
        self.DueDate.as_mut().unwrap()
    }

    // Take field
    pub fn take_DueDate(&mut self) -> TimeStamp {
        self.DueDate.take().unwrap_or_else(|| TimeStamp::new())
    }
}

impl ::protobuf::Message for MoveRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.DueDate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.TargetLocationId = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.BlockId = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.DueDate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.Id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.Id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TargetLocationId != 0 {
            my_size += ::protobuf::rt::value_size(2, self.TargetLocationId, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BlockId != 0 {
            my_size += ::protobuf::rt::value_size(3, self.BlockId, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.DueDate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.Id != 0 {
            os.write_int32(1, self.Id)?;
        }
        if self.TargetLocationId != 0 {
            os.write_int32(2, self.TargetLocationId)?;
        }
        if self.BlockId != 0 {
            os.write_int32(3, self.BlockId)?;
        }
        if let Some(ref v) = self.DueDate.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MoveRequest {
        MoveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Id",
                    |m: &MoveRequest| { &m.Id },
                    |m: &mut MoveRequest| { &mut m.Id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "TargetLocationId",
                    |m: &MoveRequest| { &m.TargetLocationId },
                    |m: &mut MoveRequest| { &mut m.TargetLocationId },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "BlockId",
                    |m: &MoveRequest| { &m.BlockId },
                    |m: &mut MoveRequest| { &mut m.BlockId },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "DueDate",
                    |m: &MoveRequest| { &m.DueDate },
                    |m: &mut MoveRequest| { &mut m.DueDate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MoveRequest>(
                    "MoveRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MoveRequest {
        static mut instance: ::protobuf::lazy::Lazy<MoveRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MoveRequest,
        };
        unsafe {
            instance.get(MoveRequest::new)
        }
    }
}

impl ::protobuf::Clear for MoveRequest {
    fn clear(&mut self) {
        self.Id = 0;
        self.TargetLocationId = 0;
        self.BlockId = 0;
        self.DueDate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MoveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Performance {
    // message fields
    pub CraneManipulations: i32,
    pub UpstreamBlocks: i32,
    pub DownstreamBlocks: i32,
    pub DeliveryErrors: i32,
    pub TotalGirderDistance: f64,
    pub TotalHoistDistance: f64,
    pub ServicedUpstreamVehicles: i32,
    pub ServicedDownstreamVehicles: i32,
    pub UpstreamServiceTime: f64,
    pub DownstreamServiceTime: f64,
    pub ParkingUpstreamVehicles: i32,
    pub ParkingDownstreamVehicles: i32,
    pub UpstreamParkingTime: f64,
    pub DownstreamParkingTime: f64,
    pub MaxParkingDuration: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Performance {
    fn default() -> &'a Performance {
        <Performance as ::protobuf::Message>::default_instance()
    }
}

impl Performance {
    pub fn new() -> Performance {
        ::std::default::Default::default()
    }

    // int32 CraneManipulations = 1;


    pub fn get_CraneManipulations(&self) -> i32 {
        self.CraneManipulations
    }
    pub fn clear_CraneManipulations(&mut self) {
        self.CraneManipulations = 0;
    }

    // Param is passed by value, moved
    pub fn set_CraneManipulations(&mut self, v: i32) {
        self.CraneManipulations = v;
    }

    // int32 UpstreamBlocks = 2;


    pub fn get_UpstreamBlocks(&self) -> i32 {
        self.UpstreamBlocks
    }
    pub fn clear_UpstreamBlocks(&mut self) {
        self.UpstreamBlocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_UpstreamBlocks(&mut self, v: i32) {
        self.UpstreamBlocks = v;
    }

    // int32 DownstreamBlocks = 3;


    pub fn get_DownstreamBlocks(&self) -> i32 {
        self.DownstreamBlocks
    }
    pub fn clear_DownstreamBlocks(&mut self) {
        self.DownstreamBlocks = 0;
    }

    // Param is passed by value, moved
    pub fn set_DownstreamBlocks(&mut self, v: i32) {
        self.DownstreamBlocks = v;
    }

    // int32 DeliveryErrors = 4;


    pub fn get_DeliveryErrors(&self) -> i32 {
        self.DeliveryErrors
    }
    pub fn clear_DeliveryErrors(&mut self) {
        self.DeliveryErrors = 0;
    }

    // Param is passed by value, moved
    pub fn set_DeliveryErrors(&mut self, v: i32) {
        self.DeliveryErrors = v;
    }

    // double TotalGirderDistance = 5;


    pub fn get_TotalGirderDistance(&self) -> f64 {
        self.TotalGirderDistance
    }
    pub fn clear_TotalGirderDistance(&mut self) {
        self.TotalGirderDistance = 0.;
    }

    // Param is passed by value, moved
    pub fn set_TotalGirderDistance(&mut self, v: f64) {
        self.TotalGirderDistance = v;
    }

    // double TotalHoistDistance = 6;


    pub fn get_TotalHoistDistance(&self) -> f64 {
        self.TotalHoistDistance
    }
    pub fn clear_TotalHoistDistance(&mut self) {
        self.TotalHoistDistance = 0.;
    }

    // Param is passed by value, moved
    pub fn set_TotalHoistDistance(&mut self, v: f64) {
        self.TotalHoistDistance = v;
    }

    // int32 ServicedUpstreamVehicles = 7;


    pub fn get_ServicedUpstreamVehicles(&self) -> i32 {
        self.ServicedUpstreamVehicles
    }
    pub fn clear_ServicedUpstreamVehicles(&mut self) {
        self.ServicedUpstreamVehicles = 0;
    }

    // Param is passed by value, moved
    pub fn set_ServicedUpstreamVehicles(&mut self, v: i32) {
        self.ServicedUpstreamVehicles = v;
    }

    // int32 ServicedDownstreamVehicles = 8;


    pub fn get_ServicedDownstreamVehicles(&self) -> i32 {
        self.ServicedDownstreamVehicles
    }
    pub fn clear_ServicedDownstreamVehicles(&mut self) {
        self.ServicedDownstreamVehicles = 0;
    }

    // Param is passed by value, moved
    pub fn set_ServicedDownstreamVehicles(&mut self, v: i32) {
        self.ServicedDownstreamVehicles = v;
    }

    // double UpstreamServiceTime = 9;


    pub fn get_UpstreamServiceTime(&self) -> f64 {
        self.UpstreamServiceTime
    }
    pub fn clear_UpstreamServiceTime(&mut self) {
        self.UpstreamServiceTime = 0.;
    }

    // Param is passed by value, moved
    pub fn set_UpstreamServiceTime(&mut self, v: f64) {
        self.UpstreamServiceTime = v;
    }

    // double DownstreamServiceTime = 10;


    pub fn get_DownstreamServiceTime(&self) -> f64 {
        self.DownstreamServiceTime
    }
    pub fn clear_DownstreamServiceTime(&mut self) {
        self.DownstreamServiceTime = 0.;
    }

    // Param is passed by value, moved
    pub fn set_DownstreamServiceTime(&mut self, v: f64) {
        self.DownstreamServiceTime = v;
    }

    // int32 ParkingUpstreamVehicles = 11;


    pub fn get_ParkingUpstreamVehicles(&self) -> i32 {
        self.ParkingUpstreamVehicles
    }
    pub fn clear_ParkingUpstreamVehicles(&mut self) {
        self.ParkingUpstreamVehicles = 0;
    }

    // Param is passed by value, moved
    pub fn set_ParkingUpstreamVehicles(&mut self, v: i32) {
        self.ParkingUpstreamVehicles = v;
    }

    // int32 ParkingDownstreamVehicles = 12;


    pub fn get_ParkingDownstreamVehicles(&self) -> i32 {
        self.ParkingDownstreamVehicles
    }
    pub fn clear_ParkingDownstreamVehicles(&mut self) {
        self.ParkingDownstreamVehicles = 0;
    }

    // Param is passed by value, moved
    pub fn set_ParkingDownstreamVehicles(&mut self, v: i32) {
        self.ParkingDownstreamVehicles = v;
    }

    // double UpstreamParkingTime = 13;


    pub fn get_UpstreamParkingTime(&self) -> f64 {
        self.UpstreamParkingTime
    }
    pub fn clear_UpstreamParkingTime(&mut self) {
        self.UpstreamParkingTime = 0.;
    }

    // Param is passed by value, moved
    pub fn set_UpstreamParkingTime(&mut self, v: f64) {
        self.UpstreamParkingTime = v;
    }

    // double DownstreamParkingTime = 14;


    pub fn get_DownstreamParkingTime(&self) -> f64 {
        self.DownstreamParkingTime
    }
    pub fn clear_DownstreamParkingTime(&mut self) {
        self.DownstreamParkingTime = 0.;
    }

    // Param is passed by value, moved
    pub fn set_DownstreamParkingTime(&mut self, v: f64) {
        self.DownstreamParkingTime = v;
    }

    // double MaxParkingDuration = 15;


    pub fn get_MaxParkingDuration(&self) -> f64 {
        self.MaxParkingDuration
    }
    pub fn clear_MaxParkingDuration(&mut self) {
        self.MaxParkingDuration = 0.;
    }

    // Param is passed by value, moved
    pub fn set_MaxParkingDuration(&mut self, v: f64) {
        self.MaxParkingDuration = v;
    }
}

impl ::protobuf::Message for Performance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.CraneManipulations = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.UpstreamBlocks = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.DownstreamBlocks = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.DeliveryErrors = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.TotalGirderDistance = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.TotalHoistDistance = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ServicedUpstreamVehicles = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ServicedDownstreamVehicles = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.UpstreamServiceTime = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.DownstreamServiceTime = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ParkingUpstreamVehicles = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ParkingDownstreamVehicles = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.UpstreamParkingTime = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.DownstreamParkingTime = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.MaxParkingDuration = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.CraneManipulations != 0 {
            my_size += ::protobuf::rt::value_size(1, self.CraneManipulations, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.UpstreamBlocks != 0 {
            my_size += ::protobuf::rt::value_size(2, self.UpstreamBlocks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DownstreamBlocks != 0 {
            my_size += ::protobuf::rt::value_size(3, self.DownstreamBlocks, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.DeliveryErrors != 0 {
            my_size += ::protobuf::rt::value_size(4, self.DeliveryErrors, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.TotalGirderDistance != 0. {
            my_size += 9;
        }
        if self.TotalHoistDistance != 0. {
            my_size += 9;
        }
        if self.ServicedUpstreamVehicles != 0 {
            my_size += ::protobuf::rt::value_size(7, self.ServicedUpstreamVehicles, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ServicedDownstreamVehicles != 0 {
            my_size += ::protobuf::rt::value_size(8, self.ServicedDownstreamVehicles, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.UpstreamServiceTime != 0. {
            my_size += 9;
        }
        if self.DownstreamServiceTime != 0. {
            my_size += 9;
        }
        if self.ParkingUpstreamVehicles != 0 {
            my_size += ::protobuf::rt::value_size(11, self.ParkingUpstreamVehicles, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ParkingDownstreamVehicles != 0 {
            my_size += ::protobuf::rt::value_size(12, self.ParkingDownstreamVehicles, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.UpstreamParkingTime != 0. {
            my_size += 9;
        }
        if self.DownstreamParkingTime != 0. {
            my_size += 9;
        }
        if self.MaxParkingDuration != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.CraneManipulations != 0 {
            os.write_int32(1, self.CraneManipulations)?;
        }
        if self.UpstreamBlocks != 0 {
            os.write_int32(2, self.UpstreamBlocks)?;
        }
        if self.DownstreamBlocks != 0 {
            os.write_int32(3, self.DownstreamBlocks)?;
        }
        if self.DeliveryErrors != 0 {
            os.write_int32(4, self.DeliveryErrors)?;
        }
        if self.TotalGirderDistance != 0. {
            os.write_double(5, self.TotalGirderDistance)?;
        }
        if self.TotalHoistDistance != 0. {
            os.write_double(6, self.TotalHoistDistance)?;
        }
        if self.ServicedUpstreamVehicles != 0 {
            os.write_int32(7, self.ServicedUpstreamVehicles)?;
        }
        if self.ServicedDownstreamVehicles != 0 {
            os.write_int32(8, self.ServicedDownstreamVehicles)?;
        }
        if self.UpstreamServiceTime != 0. {
            os.write_double(9, self.UpstreamServiceTime)?;
        }
        if self.DownstreamServiceTime != 0. {
            os.write_double(10, self.DownstreamServiceTime)?;
        }
        if self.ParkingUpstreamVehicles != 0 {
            os.write_int32(11, self.ParkingUpstreamVehicles)?;
        }
        if self.ParkingDownstreamVehicles != 0 {
            os.write_int32(12, self.ParkingDownstreamVehicles)?;
        }
        if self.UpstreamParkingTime != 0. {
            os.write_double(13, self.UpstreamParkingTime)?;
        }
        if self.DownstreamParkingTime != 0. {
            os.write_double(14, self.DownstreamParkingTime)?;
        }
        if self.MaxParkingDuration != 0. {
            os.write_double(15, self.MaxParkingDuration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Performance {
        Performance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "CraneManipulations",
                    |m: &Performance| { &m.CraneManipulations },
                    |m: &mut Performance| { &mut m.CraneManipulations },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "UpstreamBlocks",
                    |m: &Performance| { &m.UpstreamBlocks },
                    |m: &mut Performance| { &mut m.UpstreamBlocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "DownstreamBlocks",
                    |m: &Performance| { &m.DownstreamBlocks },
                    |m: &mut Performance| { &mut m.DownstreamBlocks },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "DeliveryErrors",
                    |m: &Performance| { &m.DeliveryErrors },
                    |m: &mut Performance| { &mut m.DeliveryErrors },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "TotalGirderDistance",
                    |m: &Performance| { &m.TotalGirderDistance },
                    |m: &mut Performance| { &mut m.TotalGirderDistance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "TotalHoistDistance",
                    |m: &Performance| { &m.TotalHoistDistance },
                    |m: &mut Performance| { &mut m.TotalHoistDistance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ServicedUpstreamVehicles",
                    |m: &Performance| { &m.ServicedUpstreamVehicles },
                    |m: &mut Performance| { &mut m.ServicedUpstreamVehicles },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ServicedDownstreamVehicles",
                    |m: &Performance| { &m.ServicedDownstreamVehicles },
                    |m: &mut Performance| { &mut m.ServicedDownstreamVehicles },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "UpstreamServiceTime",
                    |m: &Performance| { &m.UpstreamServiceTime },
                    |m: &mut Performance| { &mut m.UpstreamServiceTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "DownstreamServiceTime",
                    |m: &Performance| { &m.DownstreamServiceTime },
                    |m: &mut Performance| { &mut m.DownstreamServiceTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ParkingUpstreamVehicles",
                    |m: &Performance| { &m.ParkingUpstreamVehicles },
                    |m: &mut Performance| { &mut m.ParkingUpstreamVehicles },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ParkingDownstreamVehicles",
                    |m: &Performance| { &m.ParkingDownstreamVehicles },
                    |m: &mut Performance| { &mut m.ParkingDownstreamVehicles },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "UpstreamParkingTime",
                    |m: &Performance| { &m.UpstreamParkingTime },
                    |m: &mut Performance| { &mut m.UpstreamParkingTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "DownstreamParkingTime",
                    |m: &Performance| { &m.DownstreamParkingTime },
                    |m: &mut Performance| { &mut m.DownstreamParkingTime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "MaxParkingDuration",
                    |m: &Performance| { &m.MaxParkingDuration },
                    |m: &mut Performance| { &mut m.MaxParkingDuration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Performance>(
                    "Performance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Performance {
        static mut instance: ::protobuf::lazy::Lazy<Performance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Performance,
        };
        unsafe {
            instance.get(Performance::new)
        }
    }
}

impl ::protobuf::Clear for Performance {
    fn clear(&mut self) {
        self.CraneManipulations = 0;
        self.UpstreamBlocks = 0;
        self.DownstreamBlocks = 0;
        self.DeliveryErrors = 0;
        self.TotalGirderDistance = 0.;
        self.TotalHoistDistance = 0.;
        self.ServicedUpstreamVehicles = 0;
        self.ServicedDownstreamVehicles = 0;
        self.UpstreamServiceTime = 0.;
        self.DownstreamServiceTime = 0.;
        self.ParkingUpstreamVehicles = 0;
        self.ParkingDownstreamVehicles = 0;
        self.UpstreamParkingTime = 0.;
        self.DownstreamParkingTime = 0.;
        self.MaxParkingDuration = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Performance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Performance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Stack {
    // message fields
    pub BottomToTop: ::protobuf::RepeatedField<Block>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Stack {
    fn default() -> &'a Stack {
        <Stack as ::protobuf::Message>::default_instance()
    }
}

impl Stack {
    pub fn new() -> Stack {
        ::std::default::Default::default()
    }

    // repeated .DynStacking.CraneScheduling.DataModel.Block BottomToTop = 1;


    pub fn get_BottomToTop(&self) -> &[Block] {
        &self.BottomToTop
    }
    pub fn clear_BottomToTop(&mut self) {
        self.BottomToTop.clear();
    }

    // Param is passed by value, moved
    pub fn set_BottomToTop(&mut self, v: ::protobuf::RepeatedField<Block>) {
        self.BottomToTop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_BottomToTop(&mut self) -> &mut ::protobuf::RepeatedField<Block> {
        &mut self.BottomToTop
    }

    // Take field
    pub fn take_BottomToTop(&mut self) -> ::protobuf::RepeatedField<Block> {
        ::std::mem::replace(&mut self.BottomToTop, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Stack {
    fn is_initialized(&self) -> bool {
        for v in &self.BottomToTop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.BottomToTop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.BottomToTop {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.BottomToTop {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Stack {
        Stack::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Block>>(
                    "BottomToTop",
                    |m: &Stack| { &m.BottomToTop },
                    |m: &mut Stack| { &mut m.BottomToTop },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Stack>(
                    "Stack",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Stack {
        static mut instance: ::protobuf::lazy::Lazy<Stack> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Stack,
        };
        unsafe {
            instance.get(Stack::new)
        }
    }
}

impl ::protobuf::Clear for Stack {
    fn clear(&mut self) {
        self.BottomToTop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Stack {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Stack {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeStamp {
    // message fields
    pub MilliSeconds: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeStamp {
    fn default() -> &'a TimeStamp {
        <TimeStamp as ::protobuf::Message>::default_instance()
    }
}

impl TimeStamp {
    pub fn new() -> TimeStamp {
        ::std::default::Default::default()
    }

    // int64 MilliSeconds = 1;


    pub fn get_MilliSeconds(&self) -> i64 {
        self.MilliSeconds
    }
    pub fn clear_MilliSeconds(&mut self) {
        self.MilliSeconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_MilliSeconds(&mut self, v: i64) {
        self.MilliSeconds = v;
    }
}

impl ::protobuf::Message for TimeStamp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.MilliSeconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.MilliSeconds != 0 {
            my_size += ::protobuf::rt::value_size(1, self.MilliSeconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.MilliSeconds != 0 {
            os.write_int64(1, self.MilliSeconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeStamp {
        TimeStamp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "MilliSeconds",
                    |m: &TimeStamp| { &m.MilliSeconds },
                    |m: &mut TimeStamp| { &mut m.MilliSeconds },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TimeStamp>(
                    "TimeStamp",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TimeStamp {
        static mut instance: ::protobuf::lazy::Lazy<TimeStamp> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TimeStamp,
        };
        unsafe {
            instance.get(TimeStamp::new)
        }
    }
}

impl ::protobuf::Clear for TimeStamp {
    fn clear(&mut self) {
        self.MilliSeconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeStamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeStamp {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct World {
    // message fields
    pub Now: ::protobuf::SingularPtrField<TimeStamp>,
    pub Height: i32,
    pub Width: f64,
    pub Locations: ::protobuf::RepeatedField<Location>,
    pub CraneMoves: ::protobuf::RepeatedField<CraneMove>,
    pub Cranes: ::protobuf::RepeatedField<Crane>,
    pub MoveRequests: ::protobuf::RepeatedField<MoveRequest>,
    pub CraneSchedule: ::protobuf::SingularPtrField<CraneSchedule>,
    pub KPIs: ::protobuf::SingularPtrField<Performance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a World {
    fn default() -> &'a World {
        <World as ::protobuf::Message>::default_instance()
    }
}

impl World {
    pub fn new() -> World {
        ::std::default::Default::default()
    }

    // .DynStacking.CraneScheduling.DataModel.TimeStamp Now = 1;


    pub fn get_Now(&self) -> &TimeStamp {
        self.Now.as_ref().unwrap_or_else(|| TimeStamp::default_instance())
    }
    pub fn clear_Now(&mut self) {
        self.Now.clear();
    }

    pub fn has_Now(&self) -> bool {
        self.Now.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Now(&mut self, v: TimeStamp) {
        self.Now = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Now(&mut self) -> &mut TimeStamp {
        if self.Now.is_none() {
            self.Now.set_default();
        }
        self.Now.as_mut().unwrap()
    }

    // Take field
    pub fn take_Now(&mut self) -> TimeStamp {
        self.Now.take().unwrap_or_else(|| TimeStamp::new())
    }

    // int32 Height = 2;


    pub fn get_Height(&self) -> i32 {
        self.Height
    }
    pub fn clear_Height(&mut self) {
        self.Height = 0;
    }

    // Param is passed by value, moved
    pub fn set_Height(&mut self, v: i32) {
        self.Height = v;
    }

    // double Width = 3;


    pub fn get_Width(&self) -> f64 {
        self.Width
    }
    pub fn clear_Width(&mut self) {
        self.Width = 0.;
    }

    // Param is passed by value, moved
    pub fn set_Width(&mut self, v: f64) {
        self.Width = v;
    }

    // repeated .DynStacking.CraneScheduling.DataModel.Location Locations = 4;


    pub fn get_Locations(&self) -> &[Location] {
        &self.Locations
    }
    pub fn clear_Locations(&mut self) {
        self.Locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_Locations(&mut self, v: ::protobuf::RepeatedField<Location>) {
        self.Locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Locations(&mut self) -> &mut ::protobuf::RepeatedField<Location> {
        &mut self.Locations
    }

    // Take field
    pub fn take_Locations(&mut self) -> ::protobuf::RepeatedField<Location> {
        ::std::mem::replace(&mut self.Locations, ::protobuf::RepeatedField::new())
    }

    // repeated .DynStacking.CraneScheduling.DataModel.CraneMove CraneMoves = 5;


    pub fn get_CraneMoves(&self) -> &[CraneMove] {
        &self.CraneMoves
    }
    pub fn clear_CraneMoves(&mut self) {
        self.CraneMoves.clear();
    }

    // Param is passed by value, moved
    pub fn set_CraneMoves(&mut self, v: ::protobuf::RepeatedField<CraneMove>) {
        self.CraneMoves = v;
    }

    // Mutable pointer to the field.
    pub fn mut_CraneMoves(&mut self) -> &mut ::protobuf::RepeatedField<CraneMove> {
        &mut self.CraneMoves
    }

    // Take field
    pub fn take_CraneMoves(&mut self) -> ::protobuf::RepeatedField<CraneMove> {
        ::std::mem::replace(&mut self.CraneMoves, ::protobuf::RepeatedField::new())
    }

    // repeated .DynStacking.CraneScheduling.DataModel.Crane Cranes = 6;


    pub fn get_Cranes(&self) -> &[Crane] {
        &self.Cranes
    }
    pub fn clear_Cranes(&mut self) {
        self.Cranes.clear();
    }

    // Param is passed by value, moved
    pub fn set_Cranes(&mut self, v: ::protobuf::RepeatedField<Crane>) {
        self.Cranes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Cranes(&mut self) -> &mut ::protobuf::RepeatedField<Crane> {
        &mut self.Cranes
    }

    // Take field
    pub fn take_Cranes(&mut self) -> ::protobuf::RepeatedField<Crane> {
        ::std::mem::replace(&mut self.Cranes, ::protobuf::RepeatedField::new())
    }

    // repeated .DynStacking.CraneScheduling.DataModel.MoveRequest MoveRequests = 7;


    pub fn get_MoveRequests(&self) -> &[MoveRequest] {
        &self.MoveRequests
    }
    pub fn clear_MoveRequests(&mut self) {
        self.MoveRequests.clear();
    }

    // Param is passed by value, moved
    pub fn set_MoveRequests(&mut self, v: ::protobuf::RepeatedField<MoveRequest>) {
        self.MoveRequests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_MoveRequests(&mut self) -> &mut ::protobuf::RepeatedField<MoveRequest> {
        &mut self.MoveRequests
    }

    // Take field
    pub fn take_MoveRequests(&mut self) -> ::protobuf::RepeatedField<MoveRequest> {
        ::std::mem::replace(&mut self.MoveRequests, ::protobuf::RepeatedField::new())
    }

    // .DynStacking.CraneScheduling.DataModel.CraneSchedule CraneSchedule = 8;


    pub fn get_CraneSchedule(&self) -> &CraneSchedule {
        self.CraneSchedule.as_ref().unwrap_or_else(|| CraneSchedule::default_instance())
    }
    pub fn clear_CraneSchedule(&mut self) {
        self.CraneSchedule.clear();
    }

    pub fn has_CraneSchedule(&self) -> bool {
        self.CraneSchedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_CraneSchedule(&mut self, v: CraneSchedule) {
        self.CraneSchedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_CraneSchedule(&mut self) -> &mut CraneSchedule {
        if self.CraneSchedule.is_none() {
            self.CraneSchedule.set_default();
        }
        self.CraneSchedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_CraneSchedule(&mut self) -> CraneSchedule {
        self.CraneSchedule.take().unwrap_or_else(|| CraneSchedule::new())
    }

    // .DynStacking.CraneScheduling.DataModel.Performance KPIs = 9;


    pub fn get_KPIs(&self) -> &Performance {
        self.KPIs.as_ref().unwrap_or_else(|| Performance::default_instance())
    }
    pub fn clear_KPIs(&mut self) {
        self.KPIs.clear();
    }

    pub fn has_KPIs(&self) -> bool {
        self.KPIs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_KPIs(&mut self, v: Performance) {
        self.KPIs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_KPIs(&mut self) -> &mut Performance {
        if self.KPIs.is_none() {
            self.KPIs.set_default();
        }
        self.KPIs.as_mut().unwrap()
    }

    // Take field
    pub fn take_KPIs(&mut self) -> Performance {
        self.KPIs.take().unwrap_or_else(|| Performance::new())
    }
}

impl ::protobuf::Message for World {
    fn is_initialized(&self) -> bool {
        for v in &self.Now {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Locations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CraneMoves {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Cranes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.MoveRequests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.CraneSchedule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.KPIs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Now)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Height = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.Width = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Locations)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.CraneMoves)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Cranes)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.MoveRequests)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.CraneSchedule)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.KPIs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Now.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.Height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.Height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.Width != 0. {
            my_size += 9;
        }
        for value in &self.Locations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.CraneMoves {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.Cranes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.MoveRequests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.CraneSchedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.KPIs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Now.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.Height != 0 {
            os.write_int32(2, self.Height)?;
        }
        if self.Width != 0. {
            os.write_double(3, self.Width)?;
        }
        for v in &self.Locations {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.CraneMoves {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.Cranes {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.MoveRequests {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.CraneSchedule.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.KPIs.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> World {
        World::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeStamp>>(
                    "Now",
                    |m: &World| { &m.Now },
                    |m: &mut World| { &mut m.Now },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Height",
                    |m: &World| { &m.Height },
                    |m: &mut World| { &mut m.Height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "Width",
                    |m: &World| { &m.Width },
                    |m: &mut World| { &mut m.Width },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Location>>(
                    "Locations",
                    |m: &World| { &m.Locations },
                    |m: &mut World| { &mut m.Locations },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneMove>>(
                    "CraneMoves",
                    |m: &World| { &m.CraneMoves },
                    |m: &mut World| { &mut m.CraneMoves },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Crane>>(
                    "Cranes",
                    |m: &World| { &m.Cranes },
                    |m: &mut World| { &mut m.Cranes },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MoveRequest>>(
                    "MoveRequests",
                    |m: &World| { &m.MoveRequests },
                    |m: &mut World| { &mut m.MoveRequests },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CraneSchedule>>(
                    "CraneSchedule",
                    |m: &World| { &m.CraneSchedule },
                    |m: &mut World| { &mut m.CraneSchedule },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Performance>>(
                    "KPIs",
                    |m: &World| { &m.KPIs },
                    |m: &mut World| { &mut m.KPIs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<World>(
                    "World",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static World {
        static mut instance: ::protobuf::lazy::Lazy<World> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const World,
        };
        unsafe {
            instance.get(World::new)
        }
    }
}

impl ::protobuf::Clear for World {
    fn clear(&mut self) {
        self.Now.clear();
        self.Height = 0;
        self.Width = 0.;
        self.Locations.clear();
        self.CraneMoves.clear();
        self.Cranes.clear();
        self.MoveRequests.clear();
        self.CraneSchedule.clear();
        self.KPIs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for World {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for World {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CraneScheduleActivityState {
    Created = 0,
    Activatable = 1,
    Active = 2,
}

impl ::protobuf::ProtobufEnum for CraneScheduleActivityState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CraneScheduleActivityState> {
        match value {
            0 => ::std::option::Option::Some(CraneScheduleActivityState::Created),
            1 => ::std::option::Option::Some(CraneScheduleActivityState::Activatable),
            2 => ::std::option::Option::Some(CraneScheduleActivityState::Active),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CraneScheduleActivityState] = &[
            CraneScheduleActivityState::Created,
            CraneScheduleActivityState::Activatable,
            CraneScheduleActivityState::Active,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CraneScheduleActivityState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CraneScheduleActivityState {
}

impl ::std::default::Default for CraneScheduleActivityState {
    fn default() -> Self {
        CraneScheduleActivityState::Created
    }
}

impl ::protobuf::reflect::ProtobufValue for CraneScheduleActivityState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MoveType {
    MoveToPickup = 0,
    PickupAndDropoff = 1,
}

impl ::protobuf::ProtobufEnum for MoveType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MoveType> {
        match value {
            0 => ::std::option::Option::Some(MoveType::MoveToPickup),
            1 => ::std::option::Option::Some(MoveType::PickupAndDropoff),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MoveType] = &[
            MoveType::MoveToPickup,
            MoveType::PickupAndDropoff,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MoveType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MoveType {
}

impl ::std::default::Default for MoveType {
    fn default() -> Self {
        MoveType::MoveToPickup
    }
}

impl ::protobuf::reflect::ProtobufValue for MoveType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StackTypes {
    ArrivalStack = 0,
    Buffer = 1,
    HandoverStack = 2,
}

impl ::protobuf::ProtobufEnum for StackTypes {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StackTypes> {
        match value {
            0 => ::std::option::Option::Some(StackTypes::ArrivalStack),
            1 => ::std::option::Option::Some(StackTypes::Buffer),
            2 => ::std::option::Option::Some(StackTypes::HandoverStack),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StackTypes] = &[
            StackTypes::ArrivalStack,
            StackTypes::Buffer,
            StackTypes::HandoverStack,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StackTypes", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StackTypes {
}

impl ::std::default::Default for StackTypes {
    fn default() -> Self {
        StackTypes::ArrivalStack
    }
}

impl ::protobuf::reflect::ProtobufValue for StackTypes {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1bcranescheduling_model.proto\x12%DynStacking.CraneScheduling.DataMo\
    del\"-\n\x05Block\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\x12\x14\n\
    \x05Class\x18\x02\x20\x01(\x05R\x05Class\"\xa1\x02\n\x05Crane\x12\x0e\n\
    \x02Id\x18\x01\x20\x01(\x05R\x02Id\x12@\n\x04Load\x18\x02\x20\x01(\x0b2,\
    .DynStacking.CraneScheduling.DataModel.StackR\x04Load\x12&\n\x0eGirderPo\
    sition\x18\x03\x20\x01(\x01R\x0eGirderPosition\x12\x1e\n\nHoistLevel\x18\
    \x04\x20\x01(\x01R\nHoistLevel\x12$\n\rCraneCapacity\x18\x05\x20\x01(\
    \x05R\rCraneCapacity\x12\x14\n\x05Width\x18\x06\x20\x01(\x01R\x05Width\
    \x12\x20\n\x0bMinPosition\x18\x07\x20\x01(\x01R\x0bMinPosition\x12\x20\n\
    \x0bMaxPosition\x18\x08\x20\x01(\x01R\x0bMaxPosition\"\xfc\x04\n\tCraneM\
    ove\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\x12C\n\x04Type\x18\x02\
    \x20\x01(\x0e2/.DynStacking.CraneScheduling.DataModel.MoveTypeR\x04Type\
    \x12*\n\x10PickupLocationId\x18\x03\x20\x01(\x05R\x10PickupLocationId\
    \x122\n\x14PickupGirderPosition\x18\x04\x20\x01(\x01R\x14PickupGirderPos\
    ition\x12,\n\x11DropoffLocationId\x18\x05\x20\x01(\x05R\x11DropoffLocati\
    onId\x124\n\x15DropoffGirderPosition\x18\x06\x20\x01(\x01R\x15DropoffGir\
    derPosition\x12\x16\n\x06Amount\x18\x07\x20\x01(\x05R\x06Amount\x12R\n\
    \x0bReleaseTime\x18\x08\x20\x01(\x0b20.DynStacking.CraneScheduling.DataM\
    odel.TimeStampR\x0bReleaseTime\x12J\n\x07DueDate\x18\t\x20\x01(\x0b20.Dy\
    nStacking.CraneScheduling.DataModel.TimeStampR\x07DueDate\x12(\n\x0fRequ\
    iredCraneId\x18\n\x20\x01(\x05R\x0fRequiredCraneId\x12:\n\x16ProtobufPre\
    decessorIds\x18\x0c\x20\x03(\x05R\x16ProtobufPredecessorIdsB\x02\x10\0\
    \x128\n\x15ProtobufMovedBlockIds\x18\r\x20\x03(\x05R\x15ProtobufMovedBlo\
    ckIdsB\x02\x10\0\"\x8d\x01\n\rCraneSchedule\x12\x1e\n\nScheduleNr\x18\
    \x01\x20\x01(\x05R\nScheduleNr\x12\\\n\nActivities\x18\x02\x20\x03(\x0b2\
    <.DynStacking.CraneScheduling.DataModel.CraneScheduleActivityR\nActiviti\
    es\"\xbe\x01\n\x15CraneScheduleActivity\x12\x16\n\x06MoveId\x18\x01\x20\
    \x01(\x05R\x06MoveId\x12\x18\n\x07CraneId\x18\x02\x20\x01(\x05R\x07Crane\
    Id\x12\x1a\n\x08Priority\x18\x03\x20\x01(\x05R\x08Priority\x12W\n\x05Sta\
    te\x18\x04\x20\x01(\x0e2A.DynStacking.CraneScheduling.DataModel.CraneSch\
    eduleActivityStateR\x05State\"\xbf\x01\n\x17CraneSchedulingSolution\x12R\
    \n\x0bCustomMoves\x18\x01\x20\x03(\x0b20.DynStacking.CraneScheduling.Dat\
    aModel.CraneMoveR\x0bCustomMoves\x12P\n\x08Schedule\x18\x02\x20\x01(\x0b\
    24.DynStacking.CraneScheduling.DataModel.CraneScheduleR\x08Schedule\"\
    \x81\x02\n\x08Location\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\x12&\
    \n\x0eGirderPosition\x18\x02\x20\x01(\x01R\x0eGirderPosition\x12\x1c\n\t\
    MaxHeight\x18\x03\x20\x01(\x05R\tMaxHeight\x12B\n\x05Stack\x18\x04\x20\
    \x01(\x0b2,.DynStacking.CraneScheduling.DataModel.StackR\x05Stack\x12E\n\
    \x04Type\x18\x05\x20\x01(\x0e21.DynStacking.CraneScheduling.DataModel.St\
    ackTypesR\x04Type\x12\x14\n\x05Class\x18\x06\x20\x01(\x05R\x05Class\"\
    \xaf\x01\n\x0bMoveRequest\x12\x0e\n\x02Id\x18\x01\x20\x01(\x05R\x02Id\
    \x12*\n\x10TargetLocationId\x18\x02\x20\x01(\x05R\x10TargetLocationId\
    \x12\x18\n\x07BlockId\x18\x03\x20\x01(\x05R\x07BlockId\x12J\n\x07DueDate\
    \x18\x04\x20\x01(\x0b20.DynStacking.CraneScheduling.DataModel.TimeStampR\
    \x07DueDate\"\x8f\x06\n\x0bPerformance\x12.\n\x12CraneManipulations\x18\
    \x01\x20\x01(\x05R\x12CraneManipulations\x12&\n\x0eUpstreamBlocks\x18\
    \x02\x20\x01(\x05R\x0eUpstreamBlocks\x12*\n\x10DownstreamBlocks\x18\x03\
    \x20\x01(\x05R\x10DownstreamBlocks\x12&\n\x0eDeliveryErrors\x18\x04\x20\
    \x01(\x05R\x0eDeliveryErrors\x120\n\x13TotalGirderDistance\x18\x05\x20\
    \x01(\x01R\x13TotalGirderDistance\x12.\n\x12TotalHoistDistance\x18\x06\
    \x20\x01(\x01R\x12TotalHoistDistance\x12:\n\x18ServicedUpstreamVehicles\
    \x18\x07\x20\x01(\x05R\x18ServicedUpstreamVehicles\x12>\n\x1aServicedDow\
    nstreamVehicles\x18\x08\x20\x01(\x05R\x1aServicedDownstreamVehicles\x120\
    \n\x13UpstreamServiceTime\x18\t\x20\x01(\x01R\x13UpstreamServiceTime\x12\
    4\n\x15DownstreamServiceTime\x18\n\x20\x01(\x01R\x15DownstreamServiceTim\
    e\x128\n\x17ParkingUpstreamVehicles\x18\x0b\x20\x01(\x05R\x17ParkingUpst\
    reamVehicles\x12<\n\x19ParkingDownstreamVehicles\x18\x0c\x20\x01(\x05R\
    \x19ParkingDownstreamVehicles\x120\n\x13UpstreamParkingTime\x18\r\x20\
    \x01(\x01R\x13UpstreamParkingTime\x124\n\x15DownstreamParkingTime\x18\
    \x0e\x20\x01(\x01R\x15DownstreamParkingTime\x12.\n\x12MaxParkingDuration\
    \x18\x0f\x20\x01(\x01R\x12MaxParkingDuration\"W\n\x05Stack\x12N\n\x0bBot\
    tomToTop\x18\x01\x20\x03(\x0b2,.DynStacking.CraneScheduling.DataModel.Bl\
    ockR\x0bBottomToTop\"/\n\tTimeStamp\x12\"\n\x0cMilliSeconds\x18\x01\x20\
    \x01(\x03R\x0cMilliSeconds\"\xdc\x04\n\x05World\x12B\n\x03Now\x18\x01\
    \x20\x01(\x0b20.DynStacking.CraneScheduling.DataModel.TimeStampR\x03Now\
    \x12\x16\n\x06Height\x18\x02\x20\x01(\x05R\x06Height\x12\x14\n\x05Width\
    \x18\x03\x20\x01(\x01R\x05Width\x12M\n\tLocations\x18\x04\x20\x03(\x0b2/\
    .DynStacking.CraneScheduling.DataModel.LocationR\tLocations\x12P\n\nCran\
    eMoves\x18\x05\x20\x03(\x0b20.DynStacking.CraneScheduling.DataModel.Cran\
    eMoveR\nCraneMoves\x12D\n\x06Cranes\x18\x06\x20\x03(\x0b2,.DynStacking.C\
    raneScheduling.DataModel.CraneR\x06Cranes\x12V\n\x0cMoveRequests\x18\x07\
    \x20\x03(\x0b22.DynStacking.CraneScheduling.DataModel.MoveRequestR\x0cMo\
    veRequests\x12Z\n\rCraneSchedule\x18\x08\x20\x01(\x0b24.DynStacking.Cran\
    eScheduling.DataModel.CraneScheduleR\rCraneSchedule\x12F\n\x04KPIs\x18\t\
    \x20\x01(\x0b22.DynStacking.CraneScheduling.DataModel.PerformanceR\x04KP\
    Is*F\n\x1aCraneScheduleActivityState\x12\x0b\n\x07Created\x10\0\x12\x0f\
    \n\x0bActivatable\x10\x01\x12\n\n\x06Active\x10\x02*2\n\x08MoveType\x12\
    \x10\n\x0cMoveToPickup\x10\0\x12\x14\n\x10PickupAndDropoff\x10\x01*=\n\n\
    StackTypes\x12\x10\n\x0cArrivalStack\x10\0\x12\n\n\x06Buffer\x10\x01\x12\
    \x11\n\rHandoverStack\x10\x02b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
